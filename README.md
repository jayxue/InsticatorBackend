# Insticator Backend Web Services

Introduction
------------

Insticator conducts a business based on pushing contents to websites and collecting visitors' responses. This project implements RESTful Web Services supporting a simplified version of the business model.

The service supports managing (creating, updating, deleting and reading; same to other entities) of sites, users, questions, answers and extensions to answers.

Besides fundemental management functionality, the service provides extended API that:

* Enables a client widget to fetch a question for a site and a user, which is then displayed on a web page. For the same user, different questions will be fetched every time.

* Enables the client widget to send user's answers to a question to the back end, which is stored for future analysis regarding user behaviors, site activeness, site attractiveness, etc.

The project is developed with Spring Boot framework and H2 in-memory database.  

How to Run
----------

In the root of the project, run the command below to start the service:

	mvn package && java -jar target/services-1.0.0.jar

After the service is started, you can use the curl utility to send HTTP requests as commands, or use Postman to send requests in a GUI.

* To fetch a question, send a GET request to url /fetchquestion with parameters site_uuid and user_uuid.

* To catch a user's response to a question, send a POST request to url /respondquestion with parameters user_uuid, answer_id as well as extension_id
if an extension is selected.

Design Considerations
---------------------

The design differentiates non-matrix questions and matrix questions through answer extensions.

1. A non-matrix question, such as a trivia, poll and checkbox question, has a list of answers that have no extensions.

For example, for a trivia question (with id #1) "Which team won the 2017 superbowl?", there are two answers:

answer_id	answer		is_correct_answer	question_id
1			Falcons		false				1
2			Patriots	true				1

When a user (with id #1) answers the question by picking Patriots, a response is recorded as follow:

response_id	user_id	answer_id	extension_id	created_at
1			1		2			null			<a timestamp>

From answer id #2, we can find question id #1, then find the site that owns the question, so we have all information.

Note that a user can respond to the same question by selecting the same answer, if the questions was displayed again for the user, and a separate response will be recorded as follows: 

response_id	user_id	answer_id	extension_id	created_at
1			1		2			null			<a timestamp>
2			1		2			null			<another timestamp>

Although the two records seem duplicate, they actually record two facts/actions, which can be used to analyse frequency of a person visiting a site, how long the person stays on the site, etc., in the future. 


2. A matrix question has a list of answers, each with a list of extensions. For example, for a matrix question (with id #2) "Please tell us a bit about your self?", there are four answers:

answer_id	answer		is_correct_answer	question_id
3			< 18		false				2
4			18 to 35	false				2
5			35 to 55	false				2
6			> 55		false				2

For these answers, there are extensions as follows:

extension_id	extension	is_correct_extension	answer_id
1				Male		false					3
2				Female		false					3
3				Male		false					4
4				Female		false					4
5				Male		false					5
6				Female		false					5
7				Male		false					6
8				Female		false					6

When a user (with id #1) answers the question by picking "Female" for "18 to 35", a response will be recorded as follows:

response_id	user_id	answer_id	extension_id	created_at
1			1		2			null			<a timestamp>
2			1		2			null			<another timestamp>
3			1		4			2				<a third timestamp>

It is arguable that there's duplicate in such extensions. The benefit is that this design provides flexibility for having different extensions (both number and content) for each answer.

For example, making orders in a restaurant is a typical matrix question but options for each meal can be different:  

Question: What's your favorite meal?

Answers:

Meals			Options
---------------------------------------------------
Steak			Raw		Well-done
Pasta			Small	Medium		Large
Chicken Burger	Crispy	Grilled		Spicy	Regular

3. A UUID identifies a user but does not necessarily mean a real human user. A UUID should be generated by a site or client widget when a person is visiting the site. The same person may get multiple UUIDs
generated when visiting the site multiple times. The system views each UUID as a unique "user" conceptually.

Assumptions
-----------

1. The API assumes that only a single question will be displayed each time. In other words, in each call only one question is returned, which can be displayed on a page.

Technically, we can also extend the API to have it serve multiple questions for a site and a user in each call, either returning all available questions, a set of questions based on business decisions, or
a given number of questions according to parameters supplied to the call. 
 
2. The API assumes that client widget is responsible for providing correct parameters in API calls. For example, to fetch a question for a site and a user, correct site UUID and user UUID should be supplied.
The implementation performs some validation on input parameters, although more can be added.

3. The client widget knows how to display questions and answers properly. For example, when it receives a question, it should be able to check that there is only one correct answer, therefore it can generate a list of radio
buttons as only one answer can be selected. When it receives another question, it should be able to check that no answer is correct, therefore it can generate a list of checkboxes as multiple answers can be selected.

When the client receives a third question, it should be able to check that answers of the question have extensions, therefore it can generate a grid for answers and extensions.


Security Considerations
-----------------------

The API for managing questions, answers, extensions, etc. needs authentication since only authorized owner of a site has privilidge for creating, updating or deleting entities. The security can be achived by
HTTPS protocal, Basic Auth, OAuth or SSL certificate. 

The API for fetching questions and sending back responses does not need authentication since essentially users are anonymous. However, such RESTful API is always exposed to abuse.
 
The first thing to avoid is a robot keeping sending requests that may crash the server, or at least slowing it down with a huge amount of incoming requests. We can add two protections for this:

* Embed a special algorithm in the client widget. The algorithm can generate a special identification number based on the site, which is then sent along with API call request as a custom header. In the back end, the
identification number is analyzed and mapped to a valid site. Since only the client widget and back end are mutually aware of the algorithm, this can make sure that the request is indeed sent from a valid site, not from 
a robot.

* Define an acceptable time interval between two valid API calls. In a normal use case, a person visits a site, sees a question, picks an answer and goes through the process for another question. Interval between such calls can be tens
of seconds or minutes. If there are multiple incoming requests from the same site within a very short period of time, something may go wrong. Back end should check timestamps of the current request and previous calls.
If the are too close, the back end may reject such suspicious requests.

 
## Future improvements
 
1. We should add logging support for request handling. Furthermore, enable an administrator to configure logging level. Only when logging level matches logging expectations, requests as well as responses will be logged to files or
other systems for future analysis. If log level is set to a higher one, normal information does not need to be logged as logging has a performance and storage cost. Only critical events/errors will be logged.
 
2. More business logic and constraints can be added. For example, currently, for a matrix question, a user can select more than one extension for an answer, just like a user can respond more than one answer to a question.
We may need to add more attributes to differentiate whether for a specific question, only one answer can be responded, or for a specific answer, only one extension can be responded.
 
3. For frequently accessed entities such as sites, questions and answers, we can add caching to them, thus we don't need to always read from database, which will improve performance.
 
4. Currently we keep mappings of sites/users/fetched questions in memory. If the back end is restarted, the mappings would be cleared. Although restarting of back end is rare and displaying the same question
to the same user is fine, we can add persistence of the mappings, so after restarting the back end can still try to serve a new question to a user.
 
5. While caching sites/users/fetched questions in memory can well support displaying unique questions for users as well as improve performance, the map can grow significantly while more user uuids are sent from clients.
We should consider the space cost and design an exit mechanism. For example, a client can send a signal to back end to invaliate a user uuid. Or, back end can keep a timer with a limit, say 72 hours, for a uuid. If a
user uuid does not fetch any question in 72 hours, most probably the human user has left the site, thus there is no need to keep the uuid in the mapping. Meanwhile, the uuid should be kept in database since it reflects
a fact that someone visited a site, read a question and made a response.

  